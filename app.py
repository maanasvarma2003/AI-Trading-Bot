import os
import pickle
import pandas as pd
from flask import Flask, render_template, jsonify, request
import numpy as np

# Assuming all_prepared_data.pkl is generated by data_preparation.py
# and contains necessary data for models. For a real application, you'd
# load a trained model here.

app = Flask(__name__)

# Placeholder for a loaded model (conceptual)
# In a real scenario, you'd load your best trained model (RandomForest, XGBoost, or DRL agent)
class DummyModel:
    def predict_proba(self, features):
        # Simulate probabilities for BUY/SELL/HOLD
        # For a simple demo, let's make it slightly more dynamic
        buy_prob = 0.5 + (0.5 * (sum(features.iloc[0]) % 0.1))
        sell_prob = 1 - buy_prob
        return [[sell_prob, buy_prob]] # Assuming 0 for SELL, 1 for BUY

    def predict(self, features):
        # For simplicity, if buy_prob > 0.5, predict 1 (BUY), else 0 (SELL/HOLD)
        probs = self.predict_proba(features)
        return 1 if probs[0][1] > 0.5 else 0

trained_model = DummyModel() # Replace with actual loaded model

# Load prepared data (conceptual - for displaying data related info)
# In a real application, this would be more dynamic or from a DB
def load_prepared_data():
    try:
        script_dir = os.path.dirname(__file__)
        data_path = os.path.join(script_dir, 'all_prepared_data.pkl')
        if not os.path.exists(data_path):
            print(f"[ERROR] all_prepared_data.pkl not found at {data_path}")
            return None

        with open(data_path, 'rb') as f:
            all_data = pickle.load(f)
        print("[INFO] Prepared data loaded successfully for app.py.")
        return all_data
    except Exception as e:
        print(f"[ERROR] Failed to load prepared data: {e}")
        return None

prepared_data = load_prepared_data()

# --- Routes ---

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/performance_metrics')
def get_performance_metrics():
    # This is a conceptual endpoint. In a real app, you'd fetch
    # actual, up-to-date performance metrics from your running bot's database
    # or monitoring system.

    # For this example, we'll generate some dummy metrics
    # and try to use real tickers from prepared_data if available.
    metrics = {}
    sensex_tickers = []
    if prepared_data:
        sensex_tickers = list(prepared_data.keys())
    
    # Fallback to default if no prepared_data or tickers are empty
    if not sensex_tickers:
        sensex_tickers = [
            "RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "ICICIBANK.NS",
            "INFY.NS", "HINDUNILVR.NS"
        ]

    for ticker in sensex_tickers:
        # Simulate a simple prediction based on the dummy model
        # In a real setup, this would query the *live* bot or a DB for the latest signal
        dummy_features = pd.DataFrame([{'dummy_feature': 0.5}]) # Minimal dummy feature for prediction
        signal_numeric = trained_model.predict(dummy_features)
        signal_action = "BUY" if signal_numeric == 1 else "SELL" if np.random.rand() > 0.5 else "HOLD"

        metrics[ticker] = {
            "accuracy": f"{np.random.uniform(70, 95):.2f}%",
            "sharpe_ratio": f"{np.random.uniform(0.8, 2.5):.2f}",
            "last_trade_action": signal_action,
            "last_trade_time": pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')
        }
    return jsonify(metrics)

@app.route('/api/trigger_action', methods=['POST'])
def trigger_action():
    data = request.json
    action_type = data.get('action')
    status = data.get('status')

    if action_type == 'toggle_live_trading':
        # In a real system, this would interact with your running bot process
        # e.g., send a signal to a message queue, update a config file, etc.
        print(f"[INFO] Live trading toggled to: {status} (conceptual)")
        return jsonify({"message": f"Live trading successfully set to {status}."}), 200
    
    return jsonify({"message": "Unknown action."}), 400

if __name__ == '__main__':
    # Ensure the Flask app runs even if there are errors during data loading
    app.run(debug=True)
